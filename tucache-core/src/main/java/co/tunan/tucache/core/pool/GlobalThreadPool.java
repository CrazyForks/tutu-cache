package co.tunan.tucache.core.pool;

import co.tunan.tucache.core.config.TuCacheProfiles;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @title: Global thread pool for all asynchronous tasks generated by tu-cache
 * @author: trifolium.wang
 * @date: 2023/12/5
 * @modified:
 */
@Slf4j
public class GlobalThreadPool {

    /**
     * Cacheable thread pool for submitting asynchronous tasks
     */
    private static ThreadPoolExecutor pool = null;

    public static void shutdown() {
        if (pool != null && !pool.isShutdown()) {
            pool.shutdown();
        }
    }

    /**
     * 线程池任务积压长度
     */
    public static int taskBlockSize() {
        if (pool != null && !pool.isShutdown()) {
            BlockingQueue<Runnable> queue = pool.getQueue();
            return queue == null ? 0 : queue.size();
        }
        return 0;
    }

    public static void submit(Runnable task) {
        pool.submit(task);
    }

    public static void init(TuCacheProfiles tuCacheProfiles) {
        if (pool == null || pool.isTerminated()) {
            pool = new ThreadPoolExecutor(tuCacheProfiles.getPool().getCorePoolSize(),
                    tuCacheProfiles.getPool().getMaximumPoolSize(),
                    tuCacheProfiles.getPool().getKeepAliveTime(), TimeUnit.MILLISECONDS,
                    new LinkedBlockingDeque<Runnable>(Integer.MAX_VALUE) {
                        private final ReentrantLock lock = new ReentrantLock();

                        @Override
                        public boolean offer(Runnable e) {
                            lock.lock();
                            try {
                                // 策略选择为，如果没有达到最大线程数量，且当队列积压任务超过了最大线程数则增加一个新工作线程
                                if (pool.getPoolSize() < tuCacheProfiles.getPool().getMaximumPoolSize()
                                        && this.size() >= tuCacheProfiles.getPool().getMaximumPoolSize()) {
                                    return false;
                                }

                                return offerLast(e);
                            } finally {
                                lock.unlock();
                            }
                        }
                    },
                    new ThreadFactory() {
                        private final AtomicInteger threadNumber = new AtomicInteger(1);

                        @Override
                        public Thread newThread(Runnable r) {
                            final Thread t = new Thread(null, r, "tu-cache-pool-" + threadNumber.getAndIncrement());
                            t.setDaemon(false);
                            //优先级
                            if (Thread.NORM_PRIORITY != t.getPriority()) {
                                // 标准优先级
                                t.setPriority(Thread.NORM_PRIORITY);
                            }
                            return t;
                        }

                    },
                    (r, executor) -> {
                        log.error("tu-cache thread pool is full.");
                        new ThreadPoolExecutor.AbortPolicy().rejectedExecution(r, executor);
                    });
        }
    }

}
